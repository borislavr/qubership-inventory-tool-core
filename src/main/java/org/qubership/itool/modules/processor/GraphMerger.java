/*
 * Copyright 2024-2025 NetCracker Technology Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.qubership.itool.modules.processor;

import org.qubership.itool.modules.graph.Graph;
import org.qubership.itool.modules.graph.GraphDumpSupport;
import org.qubership.itool.modules.graph.GraphImpl;
import org.qubership.itool.modules.processor.matchers.CompoundVertexMatcher;
import org.qubership.itool.modules.processor.matchers.FileMatcher;
import org.qubership.itool.modules.processor.matchers.MatcherById;
import org.qubership.itool.modules.processor.matchers.SourceMocksMatcher;
import org.qubership.itool.modules.processor.matchers.TargetMocksMatcher;
import org.qubership.itool.modules.processor.matchers.VertexMatcher;
import org.qubership.itool.modules.processor.tasks.CreateAppVertexTask;
import org.qubership.itool.modules.processor.tasks.CreateTransitiveHttpDependenciesTask;
import org.qubership.itool.modules.processor.tasks.CreateTransitiveQueueDependenciesTask;
import org.qubership.itool.modules.processor.tasks.PatchAppVertexTask;
import org.qubership.itool.modules.processor.tasks.PatchIsMicroserviceFieldTask;
import org.qubership.itool.modules.processor.tasks.PatchLanguagesNormalizationTask;
import org.qubership.itool.modules.processor.tasks.PatchMockedComponentsNormalizationTask;
import org.qubership.itool.modules.processor.tasks.PatchVertexDnsNamesNormalizationTask;
import org.qubership.itool.modules.processor.tasks.RecreateDomainsStructureTask;
import org.qubership.itool.modules.processor.tasks.RecreateHttpDependenciesTask;
import org.qubership.itool.modules.report.GraphReport;
import org.qubership.itool.modules.report.GraphReportImpl;
import org.qubership.itool.utils.FutureUtils;

import io.vertx.core.Future;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;

import org.apache.commons.lang3.BooleanUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.Closeable;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static org.qubership.itool.modules.graph.Graph.CURRENT_GRAPH_MODEL_VERSION;
import static org.qubership.itool.modules.graph.Graph.F_ID;
import static org.qubership.itool.utils.JsonUtils.readJsonFile;

/**
 * <p>Merges graphs.
 *
 * <p>Standard scenario (public API): see {@link MergerApi}
 *
 * <p>Impl details:
 *
 * <p>1. Every GraphMerger instance should be {@link #close()}'d after usage.
 *
 * <p>2. See {@link GraphMetaInfoSupport} for current structure of meta-info added to
 * assembled graphs.
 *
 * <p>3. When assembling an application (according to provided description), the following vertex is created:<pre>
 * { "id" : $autogenerated, "type" : "application",
 *   "name" : $appName, "version" : $appVersion }
 * </pre>
 */
public class GraphMerger implements MergerApi, Closeable {

    private static final Logger LOGGER = LoggerFactory.getLogger(GraphMerger.class);

    private boolean failFast;

    protected Vertx vertx;
    protected boolean ownVertx;

    private boolean useDeepCopy;

    /** Use this constructor <b>only</b> if there is no {@link Vertx} instance available */
    public GraphMerger() {
        this(null, false);
    }

    public GraphMerger(Vertx vertx) {
        this(vertx, false);
    }

    public GraphMerger(Vertx vertx, boolean failFast) {
        this.failFast = failFast;
        if (vertx == null) {
            this.vertx = Vertx.vertx();
            ownVertx = true;
        } else {
            this.vertx = vertx;
            ownVertx = false;
        }
    }

    @Override
    public synchronized void close() {
        if (ownVertx && vertx != null) {
            vertx.close();
        }
        vertx = null;
    }

    public boolean isFailFast() {
        return failFast;
    }

    public void setFailFast(boolean failFast) {
        this.failFast = failFast;
    }

    //======================================================
    // Public API: All-in-one lifecycle

    @Override
    public JsonObject mergeComponentDumps(Path sourceDirectory, JsonObject targetDesc)
            throws IOException, InvalidGraphException {
        Graph graph = new GraphImpl();
        graph.setReport(new GraphReportImpl());

        prepareGraphForMerging(graph, targetDesc);
        walkAndMerge(sourceDirectory, graph, targetDesc);
        finalizeGraphAfterMerging(graph, targetDesc);

        return GraphDumpSupport.dumpToJson(graph, useDeepCopy);
    }

    @Override
    public JsonObject mergeDumps(List<DumpAndMetainfo> sourceDumps, JsonObject targetDesc)
            throws InvalidGraphException {
        Graph graph = new GraphImpl();
        graph.setReport(new GraphReportImpl());

        prepareGraphForMerging(graph, targetDesc);
        for (DumpAndMetainfo source: sourceDumps) {
            if (source == null) {
                // Invalid call. No tolerance.
                throw new InvalidGraphException(graph, "null passed to mergeDumps()");
            }
            JsonObject sourceDesc = (source.meta != null) ? source.meta : new JsonObject();
            mergeDump(source.dump, sourceDesc, graph, targetDesc);
        }
        finalizeGraphAfterMerging(graph, targetDesc);

        return GraphDumpSupport.dumpToJson(graph, useDeepCopy);
    }


    //======================================================
    // Advanced API: Customizable lifecycle

    public void prepareGraphForMerging(Graph targetGraph, JsonObject targetDesc) {
        GraphMetaInfoSupport.initMetaInfoFromDesc(targetGraph, targetDesc);
    }

    public void finalizeGraphAfterMerging(Graph targetGraph, JsonObject targetDesc) {
        Future<Void> theJob = Future.<Void>succeededFuture()
                .compose(new CreateAppVertexTask(targetDesc).thenProcessAsync(vertx, targetGraph))
                .compose(new RecreateHttpDependenciesTask().thenProcessAsync(vertx, targetGraph))
                .compose(new CreateTransitiveQueueDependenciesTask().thenProcessAsync(vertx, targetGraph))
                .compose(new CreateTransitiveHttpDependenciesTask().thenProcessAsync(vertx, targetGraph))
                .compose(new RecreateDomainsStructureTask().thenProcessAsync(vertx, targetGraph))
                ;
        FutureUtils.blockForResultOrException(theJob);

        // After the merge we should always have the latest model version
        targetGraph.setGraphVersion(CURRENT_GRAPH_MODEL_VERSION);
    }
    /**
     * Merge multiple graphs residing in a directory (and its subdirectories). Merging order is system-dependent.
     *
     * @param inputDirectory Directory to scan
     * @param targetGraph Target graph to merge all source dumps into
     * @param targetDesc Target description and merging flags
     *
     * @throws IOException If IO error happened, and throwErrors is true
     */
    public void walkAndMerge(Path inputDirectory, Graph targetGraph, JsonObject targetDesc) throws IOException
    {
        getLogger().info("Merging everything from directory {}", inputDirectory);
        List<Path> sourceFiles = new ArrayList<>();

        try (Stream<Path> walk = Files.walk(inputDirectory)) {
            walk.filter(p -> isAcceptableFile(p))
                .forEach(p -> sourceFiles.add(p));
        } catch (IOException e) {
            JsonObject sourceDesc = new JsonObject().put(P_FILE_NAME, inputDirectory.toString());
            excHappenned(e, inputDirectory.toString(), sourceDesc, targetGraph);
            // Go on: if failFast==false and IOException happens in the middle, let's process some files
        }

        for (Path path: sourceFiles) {
            JsonObject dumpFile;
            String pathString = path.toString();
            JsonObject sourceDesc = new JsonObject().put(P_FILE_NAME, pathString);
            try {
                dumpFile = readJsonFile(pathString);
            } catch (IOException e) {
                excHappenned(e, path.toString(), sourceDesc, targetGraph);
                continue;
            }

            getLogger().info("Merging source graph from {}", pathString);
            mergeDump(dumpFile, sourceDesc, targetGraph, targetDesc);
        }
    }

    /**
     * Merge another dump file into target graph. The method is designed to
     * be called several times in a row. Calling order matters, parallel
     * merging not supported.
     *
     * <p><b>Always performs shallow copies and thus may alter source dump!</b>
     *
     * @param dump Source dump
     * @param sourceDesc Source descriptor
     * @param targetGraph Merging target
     * @param targetDesc Target descriptor
     */
    public void mergeDump(JsonObject dump, JsonObject sourceDesc,
            Graph targetGraph, JsonObject targetDesc)
    {
        Graph sourceGraph;
        try {
            sourceGraph = Objects.requireNonNull( GraphDumpSupport.restoreFromJson(dump) );
        } catch (NullPointerException e) {  // Something crucial was missing
            excHappenned(e, InvalidGraphException.descToName(sourceDesc), sourceDesc, targetGraph);
            return;
        }
        normalizeGraph(targetGraph);
        mergeGraph(sourceGraph, sourceDesc, targetGraph, targetDesc, useDeepCopy);
    }

    /** Merge another {@link Graph} instance into target graph. The method is designed to
     * be called several times in a row. Calling order matters, parallel
     * merging not supported.
     *
     * @param sourceGraph Source graph
     * @param sourceDesc Source descriptor
     * @param targetGraph Merging target
     * @param targetDesc Target descriptor
     * @param deepCopy Set it to {@code true} if either {@code sourceGraph} or {@code targetGraph}
     * may be modified while another one is still used.
     */
    public void mergeGraph(Graph sourceGraph, JsonObject sourceDesc,
            Graph targetGraph, JsonObject targetDesc, boolean deepCopy)
    {
        GraphMetaInfoSupport.enrichGraphDesc(sourceGraph, sourceDesc);
        normalizeGraph(sourceGraph);

        GraphReport sourceReport = sourceGraph.getReport();
        GraphReport targetReport = targetGraph.getReport();
        try {
            mergeGraphData(sourceGraph, sourceDesc, targetGraph, targetDesc, targetReport, deepCopy);

            // If InvalidGraphException is thrown, report from source graph won't be merged
            if (targetReport != null && sourceReport != null) {
                mergeReport(sourceReport, targetReport, deepCopy);
            }

        } catch (InvalidGraphException e) {
            getLogger().error("Invalid source graph: {}", e.getMessage());

            GraphMetaInfoSupport.addDroppedItem(e, sourceDesc, targetGraph);

            if (targetReport != null) {
                targetReport.mergingError(sourceDesc, e);
            }
            if (failFast) {
                throw e;
            }
        }
    }

    protected void normalizeGraph(Graph graph) {
        Future<Void> theJob = Future.<Void>succeededFuture()
                .compose(new PatchIsMicroserviceFieldTask().thenProcessAsync(vertx, graph))
                .compose(new PatchMockedComponentsNormalizationTask().thenProcessAsync(vertx, graph))
                .compose(new PatchVertexDnsNamesNormalizationTask().thenProcessAsync(vertx, graph))
                .compose(new PatchLanguagesNormalizationTask().thenProcessAsync(vertx, graph))
                ;
        FutureUtils.blockForResultOrException(theJob);
    }


    //======================================================
    // Internal APIs, may be overridden by subclasses

    //------------------------------------------------------
    // Merging

    protected boolean isAcceptableFile(Path path) {
        String fileName = path.getFileName().toString();
        return (fileName.endsWith(".json") || fileName.endsWith(".json.gz"))
            && Files.isRegularFile(path);
    }

    protected void mergeGraphData(Graph sourceGraph, JsonObject sourceDesc,
            Graph targetGraph, JsonObject targetDesc, GraphReport targetReport, boolean deepCopy) {

        //--- Validations
        validateNoNullVertices(sourceGraph, sourceDesc, targetDesc, targetReport);
        validateInputApplication(sourceGraph, sourceDesc, targetDesc, targetReport);
        //--- Merge vertices
        // root node -- special processing
        JsonObject sourceRoot = sourceGraph.getVertex(Graph.V_ROOT);
        JsonObject targetRoot = targetGraph.getVertex(Graph.V_ROOT);
        GraphMetaInfoSupport.mergeAssemblyInfo(sourceRoot, sourceDesc, targetRoot, targetDesc);

        // Merge normal vertices. Can not be done in parallel.
        VertexMatcher matcher = createMatcher(sourceGraph, targetGraph);

        // Mapping for new vertices that were merged into existing vertices with different ids:
        // [id of vertex from the new graph +> matched id from the existing graph]
        // Existing vertices that have been remapped are not reflected here.
        Map<String, String> remapNewVertices = new HashMap<>();

        for (JsonObject vertex: sourceGraph.vertexList()) {
            String newId = vertex.getString(F_ID);
            String existingId = mergeVertex(sourceGraph, vertex, targetGraph, targetReport, matcher, deepCopy);
            if (existingId != null && !existingId.equals(newId)) {
                remapNewVertices.put(newId, existingId);
            }
        }

        //--- Merge edges.
        List<JsonObject> edgeList = sourceGraph.edgeList();
        for (JsonObject edge: edgeList) {
            mergeEdge(sourceGraph, edge, targetGraph, targetReport, remapNewVertices, deepCopy);
        }
    }

    protected VertexMatcher createMatcher(Graph sourceGraph, Graph targetGraph) {
        return new CompoundVertexMatcher(
            new MatcherById(),  // Shall be the first in list
            new TargetMocksMatcher(targetGraph),
            new SourceMocksMatcher(),
            new FileMatcher(targetGraph)
        );
    }

    protected void mergeReport(GraphReport sourceReport, GraphReport targetReport, boolean deepCopy) {
        JsonArray errors = sourceReport.dumpRecords(deepCopy);
        if (errors != null && !errors.isEmpty()) {
            for (Object error: errors) {
                targetReport.addRecord((JsonObject) error);
            }
        }
    }

    //------------------------------------------------------
    // Merging graph parts: vertices, edges

    protected String mergeVertex(Graph sourceGraph, JsonObject newVertex,
            Graph targetGraph, GraphReport targetReport,
            VertexMatcher matcher, boolean deepCopy)
    {
        String newVertexId = newVertex.getString(F_ID);
        JsonObject existingVertex = matcher.findExistingVertex(sourceGraph, newVertex, targetGraph);

        boolean newIsMock = isMockVertex(newVertex);
        if (existingVertex == null) {
            getLogger().debug("Adding new vertex: '{}' (isMock: {})", newVertexId, newIsMock);
            targetGraph.addVertex(deepCopy ? newVertex.copy() : newVertex);
            return null;
        }

        String existingId = existingVertex.getString(F_ID);
        boolean existingIsMock = isMockVertex(existingVertex);
        getLogger().debug("Existing vertex '{}' (isMock: {}) matches new vertex '{}' (isMock: {})",
                existingId, existingIsMock, newVertexId, newIsMock);

        if (existingIsMock && ! newIsMock) {
            getLogger().debug("Overwriting existing mock vertex '{}' with data from new non-mock '{}'", existingId, newVertexId);
            if (! existingId.equals(newVertexId)) {
                // The most weird case: existing vertex is mock, it shall be replaced with data from a new one with different id.
                // "id" field of existing vertex is replaced, but its object identity is retained
                targetGraph.relocateVertex(existingVertex, newVertexId);
                existingId = newVertexId;   // It will be returned, and edges from the source graph won't be relocated
            }
            Map<String, Object> map = existingVertex.getMap();
            map.clear();
            map.put(F_ID, existingId);  // Let it be the first in LinkedHashMap
            Map<String, Object> src = deepCopy ? newVertex.copy().getMap() : newVertex.getMap();
            map.putAll(src);    // puts id as well
            map.put(F_ID, existingId);
        } else if (existingIsMock == newIsMock  // Report conflict of two mocks as well
                && conflictingVertices(newVertex, existingVertex))
        {
            getLogger().error("Old vertex '{}' and new vertex '{}' (mock={} for both) conflict", existingId, newVertexId, newIsMock);
            if (targetReport != null) {
                targetReport.componentDuplicated(existingVertex, newVertex);
            }
            existingId = resolveConflict(newVertex, existingVertex, targetGraph, deepCopy);
        } else {
            // New mocks are always skipped
            getLogger().debug("Skipping new vertex '{}'", newVertexId);
        }

        return existingId;
    }

    protected boolean isMockVertex(JsonObject vertex) {
        Boolean isMock = vertex.getBoolean(Graph.F_MOCK_FLAG);
        return BooleanUtils.isTrue(isMock);
    }

    protected boolean conflictingVertices(JsonObject newVertex, JsonObject existingVertex) {
        String oldType = existingVertex.getString(Graph.F_TYPE);
        String newType = newVertex.getString(Graph.F_TYPE);
        if (! Objects.equals(oldType, newType)) {
            return true;
        }

        String oldRepo = existingVertex.getString(Graph.F_REPOSITORY);
        String newRepo = newVertex.getString(Graph.F_REPOSITORY);
        if (! Objects.equals(oldRepo, newRepo)) {
            return true;
        }

        return false;
    }

    /** Fixup conflicts for vertices matched by vertex matchers.
     * Find or create a new vertex in target graph to relocate into it.
     * This method is called when match was found, but it is conflicting.
     * Method body must be aligned with {@link #conflictingVertices(JsonObject, JsonObject)}.
     *
     * @param newVertex New vertex to merge into target graph
     * @param conflict What was matched in target graph, but found conflicting
     * @param targetGraph Target graph
     * @param deepCopy Whether deep copying is needed
     * @return ID of found or created vertex to map new vertex from source graph into
     */
    protected String resolveConflict(JsonObject newVertex, JsonObject conflict, Graph targetGraph, boolean deepCopy) {
        String conflictId = conflict.getString(F_ID);
        String newType = newVertex.getString(Graph.F_TYPE);
        String newRepo = newVertex.getString(Graph.F_REPOSITORY);
        // Let's ignore possibly multiple candidates with the same type and repository
        JsonObject candidate = targetGraph.traversal().V()
            .hasType(newType)
            .has(Graph.F_REPOSITORY, newRepo)
            .next();
        if (candidate != null) {
            // existingIsMock == newIsMock, so we won't modify candidate even if some attrs are different
            String candidateId = candidate.getString(F_ID);
            getLogger().info("Conflict resolved: mapped '{}' (conflicts with '{}') -> existing vertex '{}'",
                    newVertex.getString(F_ID), conflictId, candidateId);
            return candidateId;
        }

        String generatedId = newVertex.getString(F_ID) + "-" + UUID.randomUUID();
        candidate = new JsonObject();
        candidate.put(F_ID, generatedId);  // Let it be the first in LinkedHashMap
        Map<String, Object> src = deepCopy ? newVertex.copy().getMap() : newVertex.getMap();
        candidate.getMap().putAll(src);    // puts id as well
        candidate.put(F_ID, generatedId);

        targetGraph.addVertex(candidate);

        getLogger().info("Conflict resolved: mapped '{}' (conflicts with '{}') -> new vertex '{}'",
                newVertex.getString(F_ID), conflictId, generatedId);

        return generatedId;
    }

    /*
     * @param edgeValue An edge value itself
     * @param remapNewVertices Mapping: [id of vertex from the source graph +> correlated id from the existing graph]
     */
    protected void mergeEdge(Graph srcGraph, JsonObject edgeValue,
            Graph targetGraph, GraphReport targetReport,
            Map<String, String> remapNewVertices, boolean deepCopy)
    {
        String edgeId = edgeValue.getString(F_ID);

        // Remap source and target vertices
        String baseFromId = srcGraph.getEdgeSource(edgeId).getString(F_ID);
        String newFromId = remapNewVertices.getOrDefault(baseFromId, baseFromId);
        JsonObject sourceVertex = targetGraph.getVertex(newFromId);

        String baseToId = srcGraph.getEdgeTarget(edgeId).getString(F_ID);
        String newToId = remapNewVertices.getOrDefault(baseToId, baseToId);
        JsonObject targetVertex = targetGraph.getVertex(newToId);

        // Adds a new edge iff no edge with the same Map of properties (except id) exists
        JsonObject newEdge = deepCopy ? edgeValue.copy() : edgeValue;
        newEdge.remove(F_ID);   // Modifies source data in case of shallow copy!
        String newEdgeId = targetGraph.addEdge(sourceVertex, targetVertex, newEdge);
        if (newEdgeId != null) {
            getLogger().debug("Adding edge : was=('{}':'{}'->'{}'), now=('{}':'{}'->'{}')",
                    edgeId, baseFromId, baseToId, newEdgeId, newFromId, newToId);
        } else {
            getLogger().debug("Skipping edge : was=('{}':'{}'->'{}'), now=('{}'->'{}')",
                    edgeId, baseFromId, baseToId, newFromId, newToId);
        }
    }

    //------------------------------------------------------
    // Advanced validations and augmentations (besides external tasks)

    protected void validateNoNullVertices(Graph sourceGraph, JsonObject sourceDesc, JsonObject targetDesc, GraphReport report) {
        JsonObject nullVertex = sourceGraph.traversal().V("null").next();
        if (nullVertex != null) {   // This graph is poisoned, it shall not be consumed
            throw new InvalidGraphException(sourceDesc, "Contains null vertex");
        }
        List<JsonObject> nullRepoVertices = sourceGraph.traversal().V().hasType(Graph.V_DOMAIN)
                .out().has(Graph.F_REPOSITORY, "null").toList();
        for (JsonObject comp: nullRepoVertices) {
            // This graph is damaged, but still can be processed
            getLogger().error("Component {} has \"null\" repository", comp.getString(F_ID));
            if (report != null) {
                report.mandatoryValueMissed(comp, Graph.F_REPOSITORY);
            }
        }
    }

    protected void validateInputApplication(Graph sourceGraph, JsonObject sourceDesc, JsonObject targetDesc, GraphReport report) {
        List<JsonObject> existingApps = sourceGraph.traversal().V().hasType(Graph.V_APPLICATION).toList();

        // No matter source type and provenance, check for empty applications
        for (JsonObject existingApp: existingApps) {
            String appId = existingApp.getString(F_ID);
            JsonObject someComponent = sourceGraph.traversal().V(appId).out().next();
            if (someComponent == null) {
                report.mergingError(sourceDesc, "Application without any component: " + appId);
            }
        }

        if (! sourceDesc.getBoolean(P_IS_APPLICATION, false)) {
            // Namespace => apps may be present or not; Component => there must be no applications
            if (sourceDesc.getBoolean(P_IS_NAMESPACE, false) || existingApps.isEmpty()) {
                getLogger().debug("Source is not an application: {}", sourceDesc);
            } else {    // Not application, not namespace, some apps are present
                if (report != null) {
                    String appNames = existingApps.stream()
                        .map(app -> app.getString(Graph.F_NAME))
                        .collect(Collectors.joining(", ", "[", "]"));
                    report.mergingError(sourceDesc, "Component graph contains some application vertices: " + appNames);
                }
            }
            // For non-application origin, do not create or patch application vertex
            return;
        }

        // We have an application graph, go further

        // Support of old source artifacts without Application vertex
        if (existingApps.isEmpty()) {
            getLogger().warn("Patching the INPUT graph {} that contained no app vertex", sourceDesc);
            new CreateAppVertexTask(sourceDesc).process(sourceGraph);
            if (report != null) {
                report.mergingError(sourceDesc, "Source application graph contained no application vertex. Patched.");
            }
            return;
        }

        // Patch source Applications with unknown version if version is already known
        new PatchAppVertexTask(sourceDesc).process(sourceGraph);
    }

    //------------------------------------------------------
    // Some error handling

    /* Add dropped source to target meta-info; add message to target report; rethrow exception if needed.
     * Intended for exceptions other than InvalidGraphException. */
    protected <X extends Exception> void excHappenned(X e, String sourceId, JsonObject sourceDesc, Graph targetGraph)
            throws X
    {
        getLogger().error("Exception when processing " + sourceId, e);

        InvalidGraphException e1 = new InvalidGraphException(sourceDesc, e.getMessage());
        GraphMetaInfoSupport.addDroppedItem(e1, sourceDesc, targetGraph);

        GraphReport targetReport = targetGraph.getReport();
        if (targetReport != null) {
            targetReport.mergingError(sourceDesc, e1);
        }
        if (failFast) {
            throw e;
        }
    }

    public void setUseDeepCopy(boolean useDeepCopy) {
        this.useDeepCopy = useDeepCopy;
    }

    public Logger getLogger() {
        return LOGGER;
    }
}
